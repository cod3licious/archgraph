<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ArchGraph</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  font-size: 13px;
  background: #f5f5f5;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#app {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* ── Graph pane ── */
#graph-pane {
  flex: 1;
  overflow: auto;
  position: relative;
}

#graph-container {
  position: relative;
  margin: 0 auto;
}

/* Layer bands */
.layer-band {
  position: absolute;
  left: 0;
  right: 0;
}

.layer-band:nth-child(odd)  { background: #f0f0f0; }
.layer-band:nth-child(even) { background: #e6e6e6; }

.layer-label {
  position: absolute;
  left: 8px;
  top: 6px;
  font-size: 10px;
  color: #aaa;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  white-space: nowrap;
}

/* Arrows behind symbols, symbols behind boxes */
#arrow-svg {
  position: absolute;
  top: 0; left: 0;
  pointer-events: none;
  z-index: 1;
}

#symbol-svg {
  position: absolute;
  top: 0; left: 0;
  pointer-events: none;
  z-index: 2;
}

.submodule-box {
  position: absolute;
  border-radius: 8px;
  border: 2px solid rgba(0,0,0,0.18);
  background: white;
  cursor: pointer;
  transition: opacity 0.2s;
  min-width: 120px;
  z-index: 3;
}

.submodule-box:hover { border-color: rgba(0,0,0,0.4); }

.box-title {
  font-size: 10px;
  font-weight: 600;
  color: #444;
  padding: 3px 7px 2px;
  background: rgba(255,255,255,0.6);
  border-radius: 6px 6px 0 0;
  border-bottom: 1px solid rgba(0,0,0,0.1);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.box-units {
  padding: 5px 7px 6px;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px 8px;
}

.unit-name {
  font-size: 11px;
  color: #333;
  cursor: pointer;
  white-space: nowrap;
  transition: opacity 0.2s, font-weight 0.1s, color 0.2s;
  line-height: 1.6;
}

.unit-name:hover { text-decoration: underline; }

/* ── Resizer ── */
#resizer {
  width: 5px;
  background: #ccc;
  cursor: col-resize;
  flex-shrink: 0;
  transition: background 0.15s;
}
#resizer:hover, #resizer.dragging { background: #999; }

/* ── Detail pane ── */
#detail-pane {
  width: 20%;
  min-width: 10%;
  max-width: 40%;
  overflow-y: auto;
  background: white;
  border-left: 1px solid #ddd;
  padding: 16px;
  flex-shrink: 0;
}

#detail-pane h3 {
  font-size: 13px;
  font-weight: 700;
  color: #222;
  margin: 14px 0 4px;
  border-bottom: 1px solid #eee;
  padding-bottom: 4px;
}

#detail-pane h3:first-child { margin-top: 0; }

#detail-pane p {
  color: #444;
  line-height: 1.6;
  margin-bottom: 8px;
  font-size: 12px;
}

#detail-pane code {
  background: #f3f3f3;
  border-radius: 3px;
  padding: 0 3px;
  font-family: "SFMono-Regular", Consolas, monospace;
  font-size: 11px;
}

#detail-placeholder {
  color: #888;
  font-size: 12px;
  line-height: 1.7;
  margin-top: 4px;
}

#detail-placeholder .hint-heading {
  font-size: 13px;
  font-weight: 600;
  color: #444;
  margin-bottom: 8px;
}

#detail-placeholder .hint-item {
  margin-bottom: 6px;
  padding-left: 10px;
  border-left: 2px solid #e0e0e0;
}

/* ── Highlight states ── */
.submodule-box.dimmed  { opacity: 0.25; }
.submodule-box.focused { opacity: 1; }
.unit-name.dimmed      { opacity: 0.3; color: #999; }
.unit-name.is-selected { font-weight: 700; font-style: italic; }
.unit-name.is-callee   { font-weight: 700; }
.unit-name.is-caller   { font-style: italic; }

path.arrow { transition: opacity 0.2s; opacity: 0; }
path.arrow.visible       { opacity: 0.55; }
path.arrow.visible.violation { opacity: 1; }
path.arrow.dimmed  { opacity: 0; }

.port-symbol { transition: opacity 0.2s; }
.port-symbol.dimmed { opacity: 0.15; }
</style>
</head>
<body>
<div id="app">
  <div id="graph-pane">
    <div id="graph-container">
      <svg id="arrow-svg"></svg>
      <svg id="symbol-svg"></svg>
    </div>
  </div>
  <div id="resizer"></div>
  <div id="detail-pane">
    <div id="detail-placeholder">
      <div class="hint-heading">Click anything to explore.</div>
      <div class="hint-item"><strong>Submodules</strong> are the colored boxes — logical groupings of related functionality within a module.</div>
      <div class="hint-item"><strong>Units</strong> are the individual functions or classes listed inside each box.</div>
      <div class="hint-item">Clicking reveals the description, dependencies, and highlights which other submodules are connected — including the actual dependency lines.</div>
    </div>
    <div id="detail-content" style="display:none"></div>
  </div>
</div>

<script>
// ─── Constants ───────────────────────────────────────────────────────────────
const PAD_X = 48, PAD_Y = 40;
const BOX_GAP_X = 32, BOX_GAP_Y = 28;
const BOX_MIN_W = 130;
const UNIT_ROW_H = 20;
const TITLE_H = 26;
const BOX_PAD_Y = 10; // top+bottom padding inside box units area
const COLS_THRESHOLD = 4; // use 2 columns when unit count > this

const VALID_COLOR     = '#333'; // arrow stroke for valid dependencies
const VALID_SYM_COLOR = '#555'; // port symbol fill for valid dependencies (slightly lighter)
const VIOLATION_COLOR = '#b03a2e'; // brick red for dependency violations

const BEZIER_CP_MIN    = 20;   // minimum bezier control-point offset
const BEZIER_CP_FACTOR = 0.25; // control-point length as fraction of arc distance
const BEZIER_CP_MAX    = 120;  // maximum bezier control-point offset

// ─── Fetch & bootstrap ───────────────────────────────────────────────────────
fetch('result.json')
  .then(r => { if (!r.ok) throw new Error(r.statusText); return r.json(); })
  .then(render)
  .catch(err => {
    document.getElementById('graph-container').innerHTML =
      `<p style="padding:24px;color:${VIOLATION_COLOR}">Failed to load result.json: ${err.message}</p>`;
  });

// ─── Main render ─────────────────────────────────────────────────────────────
function render(data) {
  const { layers, submodules, units } = data;

  // 1. Determine ordered list of submodules & layer bands
  const { allSubmodules, rootBands } = flattenLayers(layers);

  // 2. Compute box sizes
  const boxSizes = computeBoxSizes(allSubmodules, submodules);

  // 3. Layout: assign (x, y) to each box
  const layout = computeLayout(layers, allSubmodules, submodules, boxSizes);

  // 4. Total canvas size
  const totalW = Math.max(...Object.values(layout).map(p => p.x + boxSizes[p.submodule].w)) + PAD_X;
  const totalH = Math.max(...Object.values(layout).map(p => p.y + boxSizes[p.submodule].h)) + PAD_Y;

  const container = document.getElementById('graph-container');
  container.style.width  = totalW + 'px';
  container.style.height = totalH + 'px';

  // 5. Draw layer bands
  drawBands(container, rootBands, layout, layers, allSubmodules, boxSizes);

  // 6. Draw boxes
  const boxEls = {};
  for (const sm of allSubmodules) {
    const pos = layout[sm];
    const sz  = boxSizes[sm];
    const box = drawBox(container, sm, submodules[sm], pos, sz);
    boxEls[sm] = box;
  }

  // 7. Draw arrows + port symbols
  const { arrowEls, portSymbolEls } = drawArrows(submodules, layout, boxSizes, totalW, totalH);

  // 8. Wire interactions
  wireInteractions(boxEls, arrowEls, portSymbolEls, submodules, units, layout, boxSizes);
}

// ─── Layer flattening ─────────────────────────────────────────────────────────
function flattenLayers(layers) {
  const allSubmodules = [];
  const rootBands = []; // {modules: string[], submodules: string[]}

  for (const rowModules of layers.root_layers) {
    const bandSubs = [];
    for (const mod of rowModules) {
      if (layers.submodule_layers && layers.submodule_layers[mod]) {
        const subRows = layers.submodule_layers[mod];
        for (const subRow of subRows)
          for (const sm of subRow) { allSubmodules.push(sm); bandSubs.push(sm); }
      } else {
        allSubmodules.push(mod);
        bandSubs.push(mod);
      }
    }
    rootBands.push({ modules: rowModules, submodules: bandSubs });
  }
  return { allSubmodules, rootBands };
}

// ─── Box sizing ───────────────────────────────────────────────────────────────
function computeBoxSizes(allSubmodules, submodules) {
  const CHAR_W = 7, COL_GAP = 12, SIDE_PAD = 28;
  const sizes = {};
  for (const sm of allSubmodules) {
    const data  = submodules[sm] || { units: [] };
    const units = data.units || [];
    const cols  = units.length > COLS_THRESHOLD ? 2 : 1;
    const rows  = Math.ceil(units.length / cols);
    const h = TITLE_H + BOX_PAD_Y + rows * UNIT_ROW_H;

    // Width: sum of max unit-name width per column + gaps + side padding
    const colWidths = Array.from({ length: cols }, (_, c) => {
      const colUnits = units.filter((_, i) => i % cols === c);
      return colUnits.length ? Math.max(...colUnits.map(u => u.length * CHAR_W)) : 0;
    });
    const titleW = sm.length * CHAR_W + SIDE_PAD;
    const colsW  = colWidths.reduce((s, w) => s + w, 0) + (cols - 1) * COL_GAP + SIDE_PAD;
    const w = Math.max(BOX_MIN_W, titleW, colsW);
    sizes[sm] = { w, h };
  }
  return sizes;
}

// ─── Layout ───────────────────────────────────────────────────────────────────
// Returns layout: { [sm]: { x, y, submodule, rowIdx } }
// rowIdx is a global vertical-row index used to detect same-row pairs for arrows.
function computeLayout(layers, allSubmodules, submodules, boxSizes) {
  const layout = {};
  // bandSms[i] = list of submodule names placed in band i (for centering pass)
  const bandSms = [];
  let bandY = PAD_Y;
  let globalRowIdx = 0;

  for (const rootRow of layers.root_layers) {
    const moduleCols = rootRow.map(mod =>
      (layers.submodule_layers && layers.submodule_layers[mod])
        ? layers.submodule_layers[mod]
        : [[mod]]
    );

    const maxSubRows = Math.max(...moduleCols.map(c => c.length));

    const rowHeights = [];
    for (let r = 0; r < maxSubRows; r++) {
      let maxH = 0;
      for (const col of moduleCols) {
        const subRow = col[r] || [];
        for (const sm of subRow) maxH = Math.max(maxH, (boxSizes[sm] || {}).h || 0);
      }
      rowHeights.push(maxH);
    }

    const thisBandSms = [];
    let colX = PAD_X;
    for (const col of moduleCols) {
      let colW = 0;
      for (const subRow of col) {
        let rowW = subRow.reduce((s, sm) => s + ((boxSizes[sm] || {}).w || 0), 0)
                 + (subRow.length - 1) * BOX_GAP_X;
        colW = Math.max(colW, rowW);
      }

      let subRowY = bandY;
      for (let r = 0; r < col.length; r++) {
        const subRow = col[r];
        const rowW = subRow.reduce((s, sm) => s + ((boxSizes[sm] || {}).w || 0), 0)
                   + (subRow.length - 1) * BOX_GAP_X;
        let smX = colX + Math.round((colW - rowW) / 2);
        for (const sm of subRow) {
          layout[sm] = { x: smX, y: subRowY, submodule: sm, rowIdx: globalRowIdx + r };
          thisBandSms.push(sm);
          smX += (boxSizes[sm] || {}).w + BOX_GAP_X;
        }
        subRowY += rowHeights[r] + BOX_GAP_Y;
      }
      colX += colW + BOX_GAP_X * 2;
    }

    bandSms.push(thisBandSms);
    globalRowIdx += maxSubRows;
    const bandH = rowHeights.reduce((s, h) => s + h, 0)
                + (maxSubRows - 1) * BOX_GAP_Y
                + BOX_PAD_Y * 2;
    bandY += bandH + BOX_GAP_Y;
  }

  // Second pass: center each band horizontally around the widest band
  const totalContentW = Math.max(...Object.values(layout).map(p => p.x + boxSizes[p.submodule].w)) - PAD_X;
  for (const sms of bandSms) {
    if (!sms.length) continue;
    const bandMinX = Math.min(...sms.map(sm => layout[sm].x));
    const bandMaxX = Math.max(...sms.map(sm => layout[sm].x + boxSizes[sm].w));
    const bandContentW = bandMaxX - bandMinX;
    const shift = Math.round((totalContentW - bandContentW) / 2);
    if (shift > 0) for (const sm of sms) layout[sm].x += shift;
  }

  return layout;
}

// ─── Draw layer bands ─────────────────────────────────────────────────────────
function drawBands(container, rootBands, layout, layers, allSubmodules, boxSizes) {
  // Compute vertical extents for each band from actual box positions
  const rootLayerRows = layers.root_layers;

  // Collect ordered submodules per root row
  for (let ri = 0; ri < rootLayerRows.length; ri++) {
    const rowModules = rootLayerRows[ri];
    const bandSubs = [];
    for (const mod of rowModules) {
      if (layers.submodule_layers && layers.submodule_layers[mod]) {
        for (const subRow of layers.submodule_layers[mod])
          for (const sm of subRow) bandSubs.push(sm);
      } else {
        bandSubs.push(mod);
      }
    }
    if (!bandSubs.length) continue;

    const ys = bandSubs.map(sm => layout[sm] ? layout[sm].y : 0);
    const yBots = bandSubs.map(sm => layout[sm] ? layout[sm].y + (boxSizes[sm] || {h:0}).h : 0);
    const top    = Math.min(...ys) - BOX_PAD_Y;
    const bottom = Math.max(...yBots) + BOX_PAD_Y;

    const band = document.createElement('div');
    band.className = 'layer-band';
    band.style.top    = top + 'px';
    band.style.height = (bottom - top) + 'px';

    const label = document.createElement('div');
    label.className = 'layer-label';
    label.textContent = rowModules.join(', ');
    band.appendChild(label);

    container.appendChild(band);
  }
}

// ─── Draw a submodule box ─────────────────────────────────────────────────────
function drawBox(container, sm, data, pos, sz) {
  const box = document.createElement('div');
  box.className = 'submodule-box';
  box.dataset.sm = sm;
  box.style.left   = pos.x + 'px';
  box.style.top    = pos.y + 'px';
  box.style.width  = sz.w + 'px';
  box.style.height = sz.h + 'px';
  box.style.backgroundColor = data.color || '#ddd';

  const title = document.createElement('div');
  title.className = 'box-title';
  title.textContent = sm;
  box.appendChild(title);

  const unitsDiv = document.createElement('div');
  unitsDiv.className = 'box-units';
  const units = data.units || [];
  const cols  = units.length > COLS_THRESHOLD ? 2 : 1;
  unitsDiv.style.gridTemplateColumns = cols === 2 ? '1fr 1fr' : '1fr';

  for (const u of units) {
    const span = document.createElement('span');
    span.className = 'unit-name';
    span.textContent = u;
    span.dataset.unit = sm + '.' + u;
    span.dataset.sm   = sm;
    unitsDiv.appendChild(span);
  }

  box.appendChild(unitsDiv);
  container.appendChild(box);
  return box;
}

// ─── Arrow drawing ────────────────────────────────────────────────────────────
function drawArrows(submodules, layout, boxSizes, totalW, totalH) {
  const svg = document.getElementById('arrow-svg');
  svg.setAttribute('width',  totalW);
  svg.setAttribute('height', totalH);
  const symSvg = document.getElementById('symbol-svg');
  symSvg.setAttribute('width',  totalW);
  symSvg.setAttribute('height', totalH);


  // Build edge list (only cross-submodule)
  const edges = []; // { from, to, valid }
  for (const [from, smData] of Object.entries(submodules)) {
    for (const [to, valid] of Object.entries(smData.dependencies || {})) {
      if (from !== to && layout[from] && layout[to])
        edges.push({ from, to, valid });
    }
  }

  // ── Unified port + symbol assignment ────────────────────────────────────────
  // For each (box, side), collect all connections (outgoing + incoming), sort
  // them valid-first then by partner center to minimize crossings, space them
  // evenly centered on the edge. The same positions serve as both the visual
  // symbols and the arrow endpoints.

  const SYM_R   = 4;  // circle radius / triangle half-size
  const SYM_GAP = 14; // center-to-center spacing between symbols on same edge
  const SYM_MARGIN = SYM_R + 4;

  // Returns which box sides a directed edge exits/enters, based on relative row/position.
  function connectionSides(from, to) {
    const rf = layout[from].rowIdx, rt = layout[to].rowIdx;
    if (rf < rt) return { fromSide: 'bottom', toSide: 'top' };
    if (rf > rt) return { fromSide: 'top',    toSide: 'bottom' };
    // Same row: route left↔right based on horizontal center positions
    const cf = layout[from].x + boxSizes[from].w / 2;
    const ct = layout[to].x   + boxSizes[to].w   / 2;
    return cf <= ct
      ? { fromSide: 'right', toSide: 'left' }
      : { fromSide: 'left',  toSide: 'right' };
  }

  // Determine which side each connection uses
  // connSide[sm][side] = [{partner, isOut, valid}, ...]
  const connSide = {};
  for (const sm of Object.keys(layout))
    connSide[sm] = { top: [], bottom: [], left: [], right: [] };

  for (const { from, to, valid } of edges) {
    const { fromSide, toSide } = connectionSides(from, to);
    connSide[from][fromSide].push({ partner: to,   isOut: true,  valid });
    connSide[to][toSide].push(    { partner: from, isOut: false, valid });
  }

  // portOut[from][to] and portIn[to][from] store {x, y, side} — set below
  const portOut = {}, portIn = {};
  for (const sm of Object.keys(layout)) { portOut[sm] = {}; portIn[sm] = {}; }

  // portSymbolEls[sm] = array of SVG elements (symbols drawn at port positions)
  const portSymbolEls = {};

  for (const sm of Object.keys(layout)) {
    const syms = [];
    const pos = layout[sm], sz = boxSizes[sm];

    for (const side of ['top', 'bottom', 'left', 'right']) {
      // Sort: valid first, then violations; within each group by partner center
      // to preserve left-right order and minimize crossings.
      const isHoriz = side === 'top' || side === 'bottom';
      const partnerCenter = p => isHoriz
        ? layout[p].x + boxSizes[p].w / 2
        : layout[p].y + boxSizes[p].h / 2;

      const items = [...connSide[sm][side]].sort((a, b) => {
        if (a.valid !== b.valid) return a.valid ? -1 : 1;
        return partnerCenter(a.partner) - partnerCenter(b.partner);
      });
      if (!items.length) continue;

      const n = items.length;
      const totalSpan = (n - 1) * SYM_GAP;
      const edgeLen = isHoriz ? sz.w : sz.h;
      const start = Math.max(SYM_MARGIN, (edgeLen - totalSpan) / 2);

      items.forEach(({ partner, isOut, valid }, i) => {
        const color = valid ? VALID_SYM_COLOR : VIOLATION_COLOR;
        const t = start + i * SYM_GAP;
        // Port position: on the box edge (used as arrow endpoint)
        let x, y;
        if      (side === 'top')    { x = pos.x + t;    y = pos.y; }
        else if (side === 'bottom') { x = pos.x + t;    y = pos.y + sz.h; }
        else if (side === 'left')   { x = pos.x;        y = pos.y + t; }
        else                        { x = pos.x + sz.w; y = pos.y + t; }

        // Register as port for arrow drawing
        if (isOut) portOut[sm][partner] = { x, y, side };
        else       portIn[sm][partner]  = { x, y, side };

        // Draw symbol
        let el;
        if (isOut) {
          let pts;
          if      (side === 'bottom') pts = `${x},${y+SYM_R*2} ${x-SYM_R},${y} ${x+SYM_R},${y}`;
          else if (side === 'top')    pts = `${x},${y-SYM_R*2} ${x-SYM_R},${y} ${x+SYM_R},${y}`;
          else if (side === 'right')  pts = `${x+SYM_R*2},${y} ${x},${y-SYM_R} ${x},${y+SYM_R}`;
          else                        pts = `${x-SYM_R*2},${y} ${x},${y-SYM_R} ${x},${y+SYM_R}`;
          el = svgEl('polygon');
          el.setAttribute('points', pts);
        } else {
          el = svgEl('circle');
          el.setAttribute('cx', x);
          el.setAttribute('cy', y);
          el.setAttribute('r', SYM_R);
        }
        el.setAttribute('fill', color);
        el.classList.add('port-symbol');
        el.dataset.sm = sm;
        el.dataset.partner = partner;
        symSvg.appendChild(el);
        syms.push(el);
      });
    }
    portSymbolEls[sm] = syms;
  }

  // Draw edges (hidden by default, shown on selection) ───────────────────────
  // Lines only — the symbols at each end already convey direction.
  const arrowEls = {};
  for (const { from, to, valid } of edges) {
    const p1 = portOut[from][to];
    const p2 = portIn[to][from];
    if (!p1 || !p2) continue;

    const path = svgEl('path');
    path.setAttribute('d', bezierPath(p1, p2));
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', valid ? VALID_COLOR : VIOLATION_COLOR);
    path.setAttribute('stroke-width', '2');
    path.classList.add('arrow');
    if (!valid) path.classList.add('violation');
    path.dataset.from = from;
    path.dataset.to   = to;
    svg.appendChild(path);
    arrowEls[`${from}->${to}`] = path;
  }

  return { arrowEls, portSymbolEls };
}

function svgEl(tag) {
  return document.createElementNS('http://www.w3.org/2000/svg', tag);
}

// Cubic bezier between two ports; control-point direction follows the port's side.
// Both outgoing (p1) and incoming (p2) control points extend outward from the box face.
function bezierPath(p1, p2) {
  const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
  const cp   = Math.min(Math.max(BEZIER_CP_MIN, dist * BEZIER_CP_FACTOR), BEZIER_CP_MAX);

  // Outward tangent vector for a given side
  const tangent = side => {
    if (side === 'bottom') return [0,  cp];
    if (side === 'top')    return [0, -cp];
    if (side === 'right')  return [ cp, 0];
    /* left */             return [-cp, 0];
  };

  const [dx1, dy1] = tangent(p1.side);
  const [dx2, dy2] = tangent(p2.side); // also outward: cp2 sits outside p2's face

  return `M${p1.x},${p1.y} C${p1.x+dx1},${p1.y+dy1} ${p2.x+dx2},${p2.y+dy2} ${p2.x},${p2.y}`;
}

// ─── Interactions ─────────────────────────────────────────────────────────────
function wireInteractions(boxEls, arrowEls, portSymbolEls, submodules, units, layout, boxSizes) {
  const graphPane = document.getElementById('graph-pane');
  let selection = null; // { type: 'submodule'|'unit', id }

  const UNIT_CLASSES = ['dimmed', 'is-selected', 'is-callee', 'is-caller'];

  function clearSelection() {
    selection = null;
    for (const el of Object.values(boxEls)) {
      el.classList.remove('dimmed', 'focused');
      for (const u of el.querySelectorAll('.unit-name'))
        u.classList.remove(...UNIT_CLASSES);
    }
    for (const el of Object.values(arrowEls))
      el.classList.remove('dimmed', 'visible');
    for (const syms of Object.values(portSymbolEls))
      for (const el of syms) el.classList.remove('dimmed');
    document.getElementById('detail-placeholder').style.display = '';
    document.getElementById('detail-content').style.display = 'none';
  }

  function applyUnitClass(el, cls) {
    // Priority: is-selected > is-callee > is-caller > dimmed
    // Once a higher-priority class is set, don't downgrade it.
    const priority = { 'is-selected': 3, 'is-callee': 2, 'is-caller': 1, 'dimmed': 0 };
    const current = UNIT_CLASSES.find(c => el.classList.contains(c));
    if (!current || priority[cls] > priority[current]) {
      el.classList.remove(...UNIT_CLASSES);
      el.classList.add(cls);
    }
  }

  // Apply dimming/highlighting to all boxes, arrows, and port symbols.
  // unitClassifier(sm, unitPath) → class to assign to each unit in a focused box.
  function applyHighlighting(relevant, relevantArrows, unitClassifier) {
    for (const [sm, el] of Object.entries(boxEls)) {
      if (relevant.has(sm)) {
        el.classList.remove('dimmed');
        el.classList.add('focused');
        for (const u of el.querySelectorAll('.unit-name')) {
          u.classList.remove(...UNIT_CLASSES);
          applyUnitClass(u, unitClassifier(sm, u.dataset.unit));
        }
      } else {
        el.classList.add('dimmed');
        el.classList.remove('focused');
        for (const u of el.querySelectorAll('.unit-name')) {
          u.classList.remove(...UNIT_CLASSES);
          u.classList.add('dimmed');
        }
      }
    }
    for (const [key, el] of Object.entries(arrowEls)) {
      if (relevantArrows.has(key)) { el.classList.add('visible'); el.classList.remove('dimmed'); }
      else { el.classList.remove('visible'); el.classList.add('dimmed'); }
    }
    for (const [sm, syms] of Object.entries(portSymbolEls))
      for (const el of syms) {
        const p = el.dataset.partner;
        if (relevantArrows.has(`${sm}->${p}`) || relevantArrows.has(`${p}->${sm}`))
          el.classList.remove('dimmed');
        else el.classList.add('dimmed');
      }
  }

  function selectSubmodule(sm) {
    selection = { type: 'submodule', id: sm };

    // Outgoing: submodules this sm depends on, and the exact units referenced
    const outDeps = Object.keys(submodules[sm]?.dependencies || {});
    const referencedUnits = new Set(
      (submodules[sm]?.units || []).flatMap(name =>
        Object.keys(units[`${sm}.${name}`]?.dependencies || {})
      )
    );

    // Incoming: submodules that depend on this sm, and the exact units that reference sm's units
    const inDeps = Object.keys(submodules).filter(s =>
      s !== sm && submodules[s].dependencies?.[sm] !== undefined
    );
    const referencingUnits = new Set(
      Object.values(units)
        .filter(u => u.submodule !== sm && Object.keys(u.dependencies || {}).some(d => units[d]?.submodule === sm))
        .map(u => `${u.submodule}.${u.name}`)
    );

    const relevant = new Set([sm, ...outDeps, ...inDeps]);
    const relevantArrows = new Set([
      ...outDeps.map(d => `${sm}->${d}`),
      ...inDeps.map(s => `${s}->${sm}`),
    ]);

    applyHighlighting(relevant, relevantArrows, (s, uPath) => {
      if (s === sm)                        return 'is-selected';
      if (referencedUnits.has(uPath))      return 'is-callee';
      if (referencingUnits.has(uPath))     return 'is-caller';
      return 'dimmed';
    });
    showSubmoduleDetail(sm, submodules[sm], units);
  }

  function selectUnit(unitPath) {
    selection = { type: 'unit', id: unitPath };
    const unitData = units[unitPath];
    if (!unitData) return;
    const sm = unitData.submodule;

    // Outgoing: units this unit depends on (may be in same or other submodules)
    const calleeUnits = new Set(Object.keys(unitData.dependencies || {}));
    const calleeSubs  = new Set([...calleeUnits].map(u => units[u]?.submodule).filter(s => s && s !== sm));

    // Incoming: units that depend on this unit
    const callerUnits = new Set(
      Object.entries(units)
        .filter(([p, u]) => p !== unitPath && u.dependencies?.[unitPath] !== undefined)
        .map(([p]) => p)
    );
    const callerSubs = new Set([...callerUnits].map(u => units[u]?.submodule).filter(s => s && s !== sm));

    const relevant = new Set([sm, ...calleeSubs, ...callerSubs]);
    const relevantArrows = new Set([
      ...[...calleeSubs].map(s => `${sm}->${s}`),
      ...[...callerSubs].map(s => `${s}->${sm}`),
    ]);

    applyHighlighting(relevant, relevantArrows, (_s, uPath) => {
      if (uPath === unitPath)          return 'is-selected';
      if (calleeUnits.has(uPath))      return 'is-callee';
      if (callerUnits.has(uPath))      return 'is-caller';
      return 'dimmed';
    });
    showUnitDetail(unitPath, unitData);
  }

  // Click on submodule box (not on a unit name)
  for (const [sm, el] of Object.entries(boxEls)) {
    el.addEventListener('click', e => {
      e.stopPropagation();
      // If click was on a unit name, handle separately
      const unitEl = e.target.closest('.unit-name');
      if (unitEl) {
        selectUnit(unitEl.dataset.unit);
      } else {
        if (selection?.type === 'submodule' && selection.id === sm) {
          clearSelection();
        } else {
          selectSubmodule(sm);
        }
      }
    });
  }

  // Click background to clear
  graphPane.addEventListener('click', e => {
    if (e.target === graphPane || e.target === document.getElementById('graph-container')
        || e.target.classList.contains('layer-band')
        || e.target.classList.contains('layer-label')) {
      clearSelection();
    }
  });
}

// ─── Detail panel rendering ───────────────────────────────────────────────────
function showSubmoduleDetail(sm, smData, units) {
  const unitNames = smData?.units || [];
  const parts = [];
  for (const name of unitNames) {
    const path = `${sm}.${name}`;
    const u = units[path];
    if (u) {
      parts.push(`<h3>${name}</h3>` + renderMarkdown(u.description || ''));
    }
  }
  setDetail(parts.join(''));
}

function showUnitDetail(unitPath, unitData) {
  const name = unitData.name || unitPath.split('.').pop();
  setDetail(`<h3>${name}</h3>` + renderMarkdown(unitData.description || ''));
}

function setDetail(html) {
  const placeholder = document.getElementById('detail-placeholder');
  const content     = document.getElementById('detail-content');
  placeholder.style.display = 'none';
  content.style.display = '';
  content.innerHTML = html;
}

// Very simple inline markdown: handles `code`, **bold**, paragraph breaks
function renderMarkdown(text) {
  // Escape HTML
  let s = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // `code`
  s = s.replace(/`([^`]+)`/g, '<code>$1</code>');

  // **bold**
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

  // Split into paragraphs on blank lines
  const paras = s.split(/\n\n+/).map(p => p.trim()).filter(Boolean);
  return paras.map(p => `<p>${p.replace(/\n/g, ' ')}</p>`).join('');
}

// ─── Resizer drag ─────────────────────────────────────────────────────────────
(function() {
  const resizer = document.getElementById('resizer');
  const detail  = document.getElementById('detail-pane');
  const app     = document.getElementById('app');
  let dragging  = false, startX = 0, startW = 0;

  resizer.addEventListener('mousedown', e => {
    dragging = true;
    startX = e.clientX;
    startW = detail.offsetWidth;
    resizer.classList.add('dragging');
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });

  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const appW   = app.offsetWidth;
    const delta  = startX - e.clientX; // moving left = wider detail
    const newW   = Math.min(appW * 0.4, Math.max(appW * 0.1, startW + delta));
    detail.style.width = newW + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = false;
    resizer.classList.remove('dragging');
    document.body.style.userSelect = '';
  });
})();
</script>
</body>
</html>
