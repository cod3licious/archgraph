<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ArchGraph</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  font-size: 13px;
  background: #f5f5f5;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#app {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* ── Graph pane ── */
#graph-pane {
  flex: 1;
  overflow: auto;
  position: relative;
}

#graph-container {
  position: relative;
  min-width: 100%;
  min-height: 100%;
}

/* Layer bands */
.layer-band {
  position: absolute;
  left: 0;
  right: 0;
}

.layer-band:nth-child(odd)  { background: #f0f0f0; }
.layer-band:nth-child(even) { background: #e6e6e6; }

.layer-label {
  position: absolute;
  left: 8px;
  top: 6px;
  font-size: 10px;
  color: #aaa;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  white-space: nowrap;
}

/* Arrow SVG overlay */
#arrow-svg {
  position: absolute;
  top: 0; left: 0;
  pointer-events: none;
  overflow: visible;
}

/* Submodule boxes */
.submodule-box {
  position: absolute;
  border-radius: 8px;
  border: 2px solid rgba(0,0,0,0.18);
  background: white;
  cursor: pointer;
  transition: opacity 0.2s;
  min-width: 120px;
}

.submodule-box:hover { border-color: rgba(0,0,0,0.4); }

.box-title {
  font-size: 10px;
  font-weight: 600;
  color: #444;
  padding: 3px 7px 2px;
  background: rgba(255,255,255,0.6);
  border-radius: 6px 6px 0 0;
  border-bottom: 1px solid rgba(0,0,0,0.1);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.box-units {
  padding: 5px 7px 6px;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px 8px;
}

.unit-name {
  font-size: 11px;
  color: #333;
  cursor: pointer;
  white-space: nowrap;
  transition: opacity 0.2s, font-weight 0.1s, color 0.2s;
  line-height: 1.6;
}

.unit-name:hover { text-decoration: underline; }

/* ── Resizer ── */
#resizer {
  width: 5px;
  background: #ccc;
  cursor: col-resize;
  flex-shrink: 0;
  transition: background 0.15s;
}
#resizer:hover, #resizer.dragging { background: #999; }

/* ── Detail pane ── */
#detail-pane {
  width: 20%;
  min-width: 10%;
  max-width: 40%;
  overflow-y: auto;
  background: white;
  border-left: 1px solid #ddd;
  padding: 16px;
  flex-shrink: 0;
}

#detail-pane h3 {
  font-size: 13px;
  font-weight: 700;
  color: #222;
  margin: 14px 0 4px;
  border-bottom: 1px solid #eee;
  padding-bottom: 4px;
}

#detail-pane h3:first-child { margin-top: 0; }

#detail-pane p {
  color: #444;
  line-height: 1.6;
  margin-bottom: 8px;
  font-size: 12px;
}

#detail-pane code {
  background: #f3f3f3;
  border-radius: 3px;
  padding: 0 3px;
  font-family: "SFMono-Regular", Consolas, monospace;
  font-size: 11px;
}

#detail-placeholder {
  color: #bbb;
  font-style: italic;
  font-size: 12px;
  margin-top: 8px;
}

/* ── Highlight states ── */
.submodule-box.dimmed  { opacity: 0.25; }
.submodule-box.focused { opacity: 1; }
.unit-name.dimmed      { opacity: 0.3; color: #999; }
.unit-name.bold        { font-weight: 700; }

path.arrow { transition: opacity 0.2s; }
path.arrow.dimmed { opacity: 0.08; }
</style>
</head>
<body>
<div id="app">
  <div id="graph-pane">
    <div id="graph-container">
      <svg id="arrow-svg"></svg>
    </div>
  </div>
  <div id="resizer"></div>
  <div id="detail-pane">
    <div id="detail-placeholder">Click a submodule or unit to see its description.</div>
    <div id="detail-content" style="display:none"></div>
  </div>
</div>

<script>
// ─── Constants ───────────────────────────────────────────────────────────────
const PAD_X = 48, PAD_Y = 40;
const BOX_GAP_X = 32, BOX_GAP_Y = 28;
const BOX_MIN_W = 130;
const UNIT_ROW_H = 20;
const TITLE_H = 26;
const BOX_PAD_Y = 10; // top+bottom padding inside box units area
const COLS_THRESHOLD = 4; // use 2 columns when unit count > this

// ─── Fetch & bootstrap ───────────────────────────────────────────────────────
fetch('result.json')
  .then(r => { if (!r.ok) throw new Error(r.statusText); return r.json(); })
  .then(render)
  .catch(err => {
    document.getElementById('graph-container').innerHTML =
      `<p style="padding:24px;color:#c00">Failed to load result.json: ${err.message}</p>`;
  });

// ─── Main render ─────────────────────────────────────────────────────────────
function render(data) {
  const { layers, submodules, units } = data;

  // 1. Determine ordered list of submodules & layer bands
  const { allSubmodules, rootBands } = flattenLayers(layers);

  // 2. Compute box sizes
  const boxSizes = computeBoxSizes(allSubmodules, submodules);

  // 3. Layout: assign (x, y) to each box
  const layout = computeLayout(layers, allSubmodules, submodules, boxSizes);

  // 4. Total canvas size
  const totalW = Math.max(...Object.values(layout).map(p => p.x + boxSizes[p.submodule].w)) + PAD_X;
  const totalH = Math.max(...Object.values(layout).map(p => p.y + boxSizes[p.submodule].h)) + PAD_Y;

  const container = document.getElementById('graph-container');
  container.style.width  = totalW + 'px';
  container.style.height = totalH + 'px';

  // 5. Draw layer bands
  drawBands(container, rootBands, layout, layers, allSubmodules, boxSizes, totalW);

  // 6. Draw boxes
  const boxEls = {};
  for (const sm of allSubmodules) {
    const pos = layout[sm];
    const sz  = boxSizes[sm];
    const box = drawBox(container, sm, submodules[sm], pos, sz);
    boxEls[sm] = box;
  }

  // 7. Draw arrows
  const arrowEls = drawArrows(submodules, layout, boxSizes, totalW, totalH);

  // 8. Wire interactions
  wireInteractions(boxEls, arrowEls, submodules, units, layout, boxSizes);
}

// ─── Layer flattening ─────────────────────────────────────────────────────────
function flattenLayers(layers) {
  const allSubmodules = [];
  const rootBands = []; // {modules: string[], submodules: string[]}

  for (const rowModules of layers.root_layers) {
    const bandSubs = [];
    for (const mod of rowModules) {
      if (layers.submodule_layers && layers.submodule_layers[mod]) {
        const subRows = layers.submodule_layers[mod];
        for (const subRow of subRows)
          for (const sm of subRow) { allSubmodules.push(sm); bandSubs.push(sm); }
      } else {
        allSubmodules.push(mod);
        bandSubs.push(mod);
      }
    }
    rootBands.push({ modules: rowModules, submodules: bandSubs });
  }
  return { allSubmodules, rootBands };
}

// ─── Box sizing ───────────────────────────────────────────────────────────────
function computeBoxSizes(allSubmodules, submodules) {
  const CHAR_W = 7, COL_GAP = 12, SIDE_PAD = 28;
  const sizes = {};
  for (const sm of allSubmodules) {
    const data  = submodules[sm] || { units: [] };
    const units = data.units || [];
    const cols  = units.length > COLS_THRESHOLD ? 2 : 1;
    const rows  = Math.ceil(units.length / cols);
    const h = TITLE_H + BOX_PAD_Y + rows * UNIT_ROW_H;

    // Width: sum of max unit-name width per column + gaps + side padding
    const colWidths = Array.from({ length: cols }, (_, c) => {
      const colUnits = units.filter((_, i) => i % cols === c);
      return colUnits.length ? Math.max(...colUnits.map(u => u.length * CHAR_W)) : 0;
    });
    const titleW = sm.length * CHAR_W + SIDE_PAD;
    const colsW  = colWidths.reduce((s, w) => s + w, 0) + (cols - 1) * COL_GAP + SIDE_PAD;
    const w = Math.max(BOX_MIN_W, titleW, colsW);
    sizes[sm] = { w, h };
  }
  return sizes;
}

// ─── Layout ───────────────────────────────────────────────────────────────────
// Each root layer row = one horizontal "band"; within a band we tile submodules
// respecting submodule_layers row ordering (submodule rows placed top-to-bottom
// within the band, modules side-by-side).
function computeLayout(layers, allSubmodules, submodules, boxSizes) {
  const layout = {};
  let bandY = PAD_Y;

  for (const rootRow of layers.root_layers) {
    // For each module in this root row, collect its submodule rows
    const moduleCols = rootRow.map(mod => {
      if (layers.submodule_layers && layers.submodule_layers[mod]) {
        return layers.submodule_layers[mod]; // list of lists
      }
      return [[mod]]; // single-item
    });

    // Determine how many submodule rows this band needs (max across modules)
    const maxSubRows = Math.max(...moduleCols.map(c => c.length));

    // For each submodule-row level, compute row height = max box height in that level
    const rowHeights = [];
    for (let r = 0; r < maxSubRows; r++) {
      let maxH = 0;
      for (const col of moduleCols) {
        const subRow = col[r] || [];
        for (const sm of subRow) maxH = Math.max(maxH, (boxSizes[sm] || {}).h || 0);
      }
      rowHeights.push(maxH);
    }

    // Assign x positions: modules side by side, submodules within each module
    let colX = PAD_X;
    for (const col of moduleCols) {
      // Width of this module column = max total width of any submodule row
      let colW = 0;
      for (const subRow of col) {
        let rowW = 0;
        for (const sm of subRow) rowW += (boxSizes[sm] || {}).w || 0;
        rowW += (subRow.length - 1) * BOX_GAP_X;
        colW = Math.max(colW, rowW);
      }

      let subRowY = bandY;
      for (let r = 0; r < col.length; r++) {
        const subRow = col[r];
        // Center the subrow within the column width
        const rowW = subRow.reduce((s, sm) => s + (boxSizes[sm] || {}).w || 0, 0)
                   + (subRow.length - 1) * BOX_GAP_X;
        let smX = colX + Math.round((colW - rowW) / 2);
        for (const sm of subRow) {
          layout[sm] = { x: smX, y: subRowY, submodule: sm };
          smX += (boxSizes[sm] || {}).w + BOX_GAP_X;
        }
        subRowY += rowHeights[r] + BOX_GAP_Y;
      }
      colX += colW + BOX_GAP_X * 2;
    }

    const bandH = rowHeights.reduce((s, h) => s + h, 0)
                + (maxSubRows - 1) * BOX_GAP_Y
                + BOX_PAD_Y * 2;
    bandY += bandH + BOX_GAP_Y;
  }

  return layout;
}

// ─── Draw layer bands ─────────────────────────────────────────────────────────
function drawBands(container, rootBands, layout, layers, allSubmodules, boxSizes, totalW) {
  // Compute vertical extents for each band from actual box positions
  let bandIdx = 0;
  let smIdx = 0;
  const rootLayerRows = layers.root_layers;

  // Collect ordered submodules per root row
  for (let ri = 0; ri < rootLayerRows.length; ri++) {
    const rowModules = rootLayerRows[ri];
    const bandSubs = [];
    for (const mod of rowModules) {
      if (layers.submodule_layers && layers.submodule_layers[mod]) {
        for (const subRow of layers.submodule_layers[mod])
          for (const sm of subRow) bandSubs.push(sm);
      } else {
        bandSubs.push(mod);
      }
    }
    if (!bandSubs.length) continue;

    const ys = bandSubs.map(sm => layout[sm] ? layout[sm].y : 0);
    const yBots = bandSubs.map(sm => layout[sm] ? layout[sm].y + (boxSizes[sm] || {h:0}).h : 0);
    const top    = Math.min(...ys) - BOX_PAD_Y;
    const bottom = Math.max(...yBots) + BOX_PAD_Y;

    const band = document.createElement('div');
    band.className = 'layer-band';
    band.style.top    = top + 'px';
    band.style.height = (bottom - top) + 'px';
    band.style.width  = totalW + 'px';

    const label = document.createElement('div');
    label.className = 'layer-label';
    label.textContent = rowModules.join(', ');
    band.appendChild(label);

    container.appendChild(band);
  }
}

// ─── Draw a submodule box ─────────────────────────────────────────────────────
function drawBox(container, sm, data, pos, sz) {
  const box = document.createElement('div');
  box.className = 'submodule-box';
  box.dataset.sm = sm;
  box.style.left   = pos.x + 'px';
  box.style.top    = pos.y + 'px';
  box.style.width  = sz.w + 'px';
  box.style.height = sz.h + 'px';
  box.style.backgroundColor = data.color || '#ddd';

  const title = document.createElement('div');
  title.className = 'box-title';
  title.textContent = sm;
  box.appendChild(title);

  const unitsDiv = document.createElement('div');
  unitsDiv.className = 'box-units';
  const units = data.units || [];
  const cols  = units.length > COLS_THRESHOLD ? 2 : 1;
  unitsDiv.style.gridTemplateColumns = cols === 2 ? '1fr 1fr' : '1fr';

  for (const u of units) {
    const span = document.createElement('span');
    span.className = 'unit-name';
    span.textContent = u;
    span.dataset.unit = sm + '.' + u;
    span.dataset.sm   = sm;
    unitsDiv.appendChild(span);
  }

  box.appendChild(unitsDiv);
  container.appendChild(box);
  return box;
}

// ─── Arrow drawing ────────────────────────────────────────────────────────────
function drawArrows(submodules, layout, boxSizes, totalW, totalH) {
  const svg = document.getElementById('arrow-svg');
  svg.setAttribute('width',  totalW);
  svg.setAttribute('height', totalH);

  // Define arrowhead markers
  const defs = svgEl('defs');
  for (const [id, color] of [['arr-black','#333'], ['arr-red','#c00']]) {
    const marker = svgEl('marker');
    marker.setAttribute('id', id);
    marker.setAttribute('markerWidth', '8');
    marker.setAttribute('markerHeight', '8');
    marker.setAttribute('refX', '6');
    marker.setAttribute('refY', '3');
    marker.setAttribute('orient', 'auto');
    const poly = svgEl('path');
    poly.setAttribute('d', 'M0,0 L0,6 L8,3 z');
    poly.setAttribute('fill', color);
    marker.appendChild(poly);
    defs.appendChild(marker);
  }
  svg.appendChild(defs);

  const arrowEls = {}; // key: "from->to"

  // Pre-compute bidirectional pairs for offset assignment
  const bidiPairs = new Set();
  for (const [fromSm, smData] of Object.entries(submodules)) {
    for (const toSm of Object.keys(smData.dependencies || {})) {
      if (fromSm !== toSm && (submodules[toSm]?.dependencies || {})[fromSm] !== undefined)
        bidiPairs.add([fromSm, toSm].sort().join('<->'));
    }
  }

  for (const [fromSm, smData] of Object.entries(submodules)) {
    for (const [toSm, valid] of Object.entries(smData.dependencies || {})) {
      if (fromSm === toSm) continue;
      const fromPos = layout[fromSm];
      const toPos   = layout[toSm];
      if (!fromPos || !toPos) continue;

      const fromSz = boxSizes[fromSm];
      const toSz   = boxSizes[toSm];
      const color  = valid ? '#333' : '#c00';
      const markerId = valid ? 'arr-black' : 'arr-red';

      // Bidirectional arrows get opposite lateral offsets so they don't overlap
      const bidiKey  = [fromSm, toSm].sort().join('<->');
      const bidiSign = bidiPairs.has(bidiKey) ? (fromSm < toSm ? 1 : -1) : 0;

      const d = arrowPath(fromPos, fromSz, toPos, toSz, bidiSign);

      const path = svgEl('path');
      path.setAttribute('d', d);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', color);
      path.setAttribute('stroke-width', '1.5');
      path.setAttribute('marker-end', `url(#${markerId})`);
      path.setAttribute('opacity', '0.7');
      path.classList.add('arrow');
      path.dataset.from = fromSm;
      path.dataset.to   = toSm;
      svg.appendChild(path);

      arrowEls[`${fromSm}->${toSm}`] = path;
    }
  }

  return arrowEls;
}

function svgEl(tag) {
  return document.createElementNS('http://www.w3.org/2000/svg', tag);
}

// Compute a bezier arrow path from fromBox to toBox.
// bidiSign: 0 = no offset, +1/-1 = lateral offset direction for bidi pairs
function arrowPath(fromPos, fromSz, toPos, toSz, bidiSign) {
  const BIDI_OFFSET = 12;

  const fromCX = fromPos.x + fromSz.w / 2;
  const fromCY = fromPos.y + fromSz.h / 2;
  const toCX   = toPos.x + toSz.w / 2;
  const toCY   = toPos.y + toSz.h / 2;
  const dx = toCX - fromCX;
  const dy = toCY - fromCY;

  let x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2;
  const off = bidiSign * BIDI_OFFSET;

  if (Math.abs(dy) >= Math.abs(dx)) {
    // Mostly vertical: exit bottom/top, offset horizontally
    const goDown = dy > 0;
    x1 = fromPos.x + fromSz.w * 0.5 + off;
    y1 = goDown ? fromPos.y + fromSz.h : fromPos.y;
    x2 = toPos.x + toSz.w * 0.5 + off;
    y2 = goDown ? toPos.y : toPos.y + toSz.h;
    const cp = Math.abs(dy) * 0.45;
    cpx1 = x1; cpy1 = y1 + (goDown ? cp : -cp);
    cpx2 = x2; cpy2 = y2 + (goDown ? -cp : cp);
  } else {
    // Mostly horizontal: exit right/left, offset vertically
    const goRight = dx > 0;
    x1 = goRight ? fromPos.x + fromSz.w : fromPos.x;
    y1 = fromPos.y + fromSz.h * 0.5 + off;
    x2 = goRight ? toPos.x : toPos.x + toSz.w;
    y2 = toPos.y + toSz.h * 0.5 + off;
    const cp = Math.abs(dx) * 0.45;
    cpx1 = x1 + (goRight ? cp : -cp); cpy1 = y1;
    cpx2 = x2 + (goRight ? -cp : cp); cpy2 = y2;
  }

  return `M${x1},${y1} C${cpx1},${cpy1} ${cpx2},${cpy2} ${x2},${y2}`;
}

// ─── Interactions ─────────────────────────────────────────────────────────────
function wireInteractions(boxEls, arrowEls, submodules, units, layout, boxSizes) {
  const graphPane = document.getElementById('graph-pane');
  let selection = null; // { type: 'submodule'|'unit', id }

  function clearSelection() {
    selection = null;
    for (const el of Object.values(boxEls)) {
      el.classList.remove('dimmed', 'focused');
      for (const u of el.querySelectorAll('.unit-name'))
        u.classList.remove('dimmed', 'bold');
    }
    for (const el of Object.values(arrowEls))
      el.classList.remove('dimmed');
    document.getElementById('detail-placeholder').style.display = '';
    document.getElementById('detail-content').style.display = 'none';
  }

  function selectSubmodule(sm) {
    selection = { type: 'submodule', id: sm };
    const deps = Object.keys(submodules[sm]?.dependencies || {});
    const relevant = new Set([sm, ...deps]);
    const relevantArrows = new Set(
      deps.map(d => `${sm}->${d}`)
    );

    for (const [s, el] of Object.entries(boxEls)) {
      if (relevant.has(s)) {
        el.classList.remove('dimmed');
        el.classList.add('focused');
        for (const u of el.querySelectorAll('.unit-name')) {
          if (s === sm || relevant.has(u.dataset.sm)) {
            u.classList.remove('dimmed');
            u.classList.add('bold');
          } else {
            u.classList.add('dimmed');
            u.classList.remove('bold');
          }
        }
      } else {
        el.classList.add('dimmed');
        el.classList.remove('focused');
        for (const u of el.querySelectorAll('.unit-name')) {
          u.classList.add('dimmed');
          u.classList.remove('bold');
        }
      }
    }

    for (const [key, el] of Object.entries(arrowEls)) {
      if (relevantArrows.has(key)) el.classList.remove('dimmed');
      else el.classList.add('dimmed');
    }

    showSubmoduleDetail(sm, submodules[sm], units);
  }

  function selectUnit(unitPath) {
    selection = { type: 'unit', id: unitPath };
    const unitData = units[unitPath];
    if (!unitData) return;
    const sm  = unitData.submodule;
    const depUnits = Object.keys(unitData.dependencies || {});
    const depSubmodules = new Set(depUnits.map(u => units[u]?.submodule).filter(Boolean));
    depSubmodules.delete(sm); // intra-submodule deps don't get arrows

    const relevantArrows = new Set();
    for (const depSm of depSubmodules)
      relevantArrows.add(`${sm}->${depSm}`);

    for (const [s, el] of Object.entries(boxEls)) {
      const isOwn = s === sm;
      const isDep = depSubmodules.has(s);
      if (isOwn || isDep) {
        el.classList.remove('dimmed');
        el.classList.add('focused');
        for (const u of el.querySelectorAll('.unit-name')) {
          const uPath = u.dataset.unit;
          if (uPath === unitPath || depUnits.includes(uPath)) {
            u.classList.remove('dimmed');
            u.classList.add('bold');
          } else {
            u.classList.add('dimmed');
            u.classList.remove('bold');
          }
        }
      } else {
        el.classList.add('dimmed');
        el.classList.remove('focused');
        for (const u of el.querySelectorAll('.unit-name')) {
          u.classList.add('dimmed');
          u.classList.remove('bold');
        }
      }
    }

    for (const [key, el] of Object.entries(arrowEls)) {
      if (relevantArrows.has(key)) el.classList.remove('dimmed');
      else el.classList.add('dimmed');
    }

    showUnitDetail(unitPath, unitData);
  }

  // Click on submodule box (not on a unit name)
  for (const [sm, el] of Object.entries(boxEls)) {
    el.addEventListener('click', e => {
      e.stopPropagation();
      // If click was on a unit name, handle separately
      const unitEl = e.target.closest('.unit-name');
      if (unitEl) {
        selectUnit(unitEl.dataset.unit);
      } else {
        if (selection?.type === 'submodule' && selection.id === sm) {
          clearSelection();
        } else {
          selectSubmodule(sm);
        }
      }
    });
  }

  // Click background to clear
  graphPane.addEventListener('click', e => {
    if (e.target === graphPane || e.target === document.getElementById('graph-container')
        || e.target.classList.contains('layer-band')
        || e.target.classList.contains('layer-label')) {
      clearSelection();
    }
  });
}

// ─── Detail panel rendering ───────────────────────────────────────────────────
function showSubmoduleDetail(sm, smData, units) {
  const unitNames = smData?.units || [];
  const parts = [];
  for (const name of unitNames) {
    const path = `${sm}.${name}`;
    const u = units[path];
    if (u) {
      parts.push(`<h3>${name}</h3>` + renderMarkdown(u.description || ''));
    }
  }
  setDetail(parts.join(''));
}

function showUnitDetail(unitPath, unitData) {
  const name = unitData.name || unitPath.split('.').pop();
  setDetail(`<h3>${name}</h3>` + renderMarkdown(unitData.description || ''));
}

function setDetail(html) {
  const placeholder = document.getElementById('detail-placeholder');
  const content     = document.getElementById('detail-content');
  placeholder.style.display = 'none';
  content.style.display = '';
  content.innerHTML = html;
}

// Very simple inline markdown: handles `code`, **bold**, paragraph breaks
function renderMarkdown(text) {
  // Escape HTML
  let s = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // `code`
  s = s.replace(/`([^`]+)`/g, '<code>$1</code>');

  // **bold**
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

  // Split into paragraphs on blank lines
  const paras = s.split(/\n\n+/).map(p => p.trim()).filter(Boolean);
  return paras.map(p => `<p>${p.replace(/\n/g, ' ')}</p>`).join('');
}

// ─── Resizer drag ─────────────────────────────────────────────────────────────
(function() {
  const resizer = document.getElementById('resizer');
  const detail  = document.getElementById('detail-pane');
  const app     = document.getElementById('app');
  let dragging  = false, startX = 0, startW = 0;

  resizer.addEventListener('mousedown', e => {
    dragging = true;
    startX = e.clientX;
    startW = detail.offsetWidth;
    resizer.classList.add('dragging');
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });

  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const appW   = app.offsetWidth;
    const delta  = startX - e.clientX; // moving left = wider detail
    const newW   = Math.min(appW * 0.4, Math.max(appW * 0.1, startW + delta));
    detail.style.width = newW + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = false;
    resizer.classList.remove('dragging');
    document.body.style.userSelect = '';
  });
})();
</script>
</body>
</html>
