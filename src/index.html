<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ArchGraph</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  font-size: 13px;
  background: #f5f5f5;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#app {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* ── Graph pane ── */
#graph-pane {
  flex: 1;
  overflow: auto;
  position: relative;
}

#graph-container {
  position: relative;
  min-width: 100%;
  min-height: 100%;
}

/* Layer bands */
.layer-band {
  position: absolute;
  left: 0;
  right: 0;
}

.layer-band:nth-child(odd)  { background: #f0f0f0; }
.layer-band:nth-child(even) { background: #e6e6e6; }

.layer-label {
  position: absolute;
  left: 8px;
  top: 6px;
  font-size: 10px;
  color: #aaa;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  white-space: nowrap;
}

/* Arrow SVG overlay — sits above bands (z:1) but below boxes (z:2) */
#arrow-svg {
  position: absolute;
  top: 0; left: 0;
  pointer-events: none;
  overflow: visible;
  z-index: 1;
}

/* Submodule boxes */
.submodule-box {
  position: absolute;
  border-radius: 8px;
  border: 2px solid rgba(0,0,0,0.18);
  background: white;
  cursor: pointer;
  transition: opacity 0.2s;
  min-width: 120px;
  z-index: 2;
}

.submodule-box:hover { border-color: rgba(0,0,0,0.4); }

.box-title {
  font-size: 10px;
  font-weight: 600;
  color: #444;
  padding: 3px 7px 2px;
  background: rgba(255,255,255,0.6);
  border-radius: 6px 6px 0 0;
  border-bottom: 1px solid rgba(0,0,0,0.1);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.box-units {
  padding: 5px 7px 6px;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px 8px;
}

.unit-name {
  font-size: 11px;
  color: #333;
  cursor: pointer;
  white-space: nowrap;
  transition: opacity 0.2s, font-weight 0.1s, color 0.2s;
  line-height: 1.6;
}

.unit-name:hover { text-decoration: underline; }

/* ── Resizer ── */
#resizer {
  width: 5px;
  background: #ccc;
  cursor: col-resize;
  flex-shrink: 0;
  transition: background 0.15s;
}
#resizer:hover, #resizer.dragging { background: #999; }

/* ── Detail pane ── */
#detail-pane {
  width: 20%;
  min-width: 10%;
  max-width: 40%;
  overflow-y: auto;
  background: white;
  border-left: 1px solid #ddd;
  padding: 16px;
  flex-shrink: 0;
}

#detail-pane h3 {
  font-size: 13px;
  font-weight: 700;
  color: #222;
  margin: 14px 0 4px;
  border-bottom: 1px solid #eee;
  padding-bottom: 4px;
}

#detail-pane h3:first-child { margin-top: 0; }

#detail-pane p {
  color: #444;
  line-height: 1.6;
  margin-bottom: 8px;
  font-size: 12px;
}

#detail-pane code {
  background: #f3f3f3;
  border-radius: 3px;
  padding: 0 3px;
  font-family: "SFMono-Regular", Consolas, monospace;
  font-size: 11px;
}

#detail-placeholder {
  color: #bbb;
  font-style: italic;
  font-size: 12px;
  margin-top: 8px;
}

/* ── Highlight states ── */
.submodule-box.dimmed  { opacity: 0.25; }
.submodule-box.focused { opacity: 1; }
.unit-name.dimmed      { opacity: 0.3; color: #999; }
.unit-name.is-selected { font-weight: 700; font-style: italic; }
.unit-name.is-callee   { font-weight: 700; }
.unit-name.is-caller   { font-style: italic; }

path.arrow { transition: opacity 0.2s; }
path.arrow.dimmed { opacity: 0.08; }
</style>
</head>
<body>
<div id="app">
  <div id="graph-pane">
    <div id="graph-container">
      <svg id="arrow-svg"></svg>
    </div>
  </div>
  <div id="resizer"></div>
  <div id="detail-pane">
    <div id="detail-placeholder">Click a submodule or unit to see its description.</div>
    <div id="detail-content" style="display:none"></div>
  </div>
</div>

<script>
// ─── Constants ───────────────────────────────────────────────────────────────
const PAD_X = 48, PAD_Y = 40;
const BOX_GAP_X = 32, BOX_GAP_Y = 28;
const BOX_MIN_W = 130;
const UNIT_ROW_H = 20;
const TITLE_H = 26;
const BOX_PAD_Y = 10; // top+bottom padding inside box units area
const COLS_THRESHOLD = 4; // use 2 columns when unit count > this

// ─── Fetch & bootstrap ───────────────────────────────────────────────────────
fetch('result.json')
  .then(r => { if (!r.ok) throw new Error(r.statusText); return r.json(); })
  .then(render)
  .catch(err => {
    document.getElementById('graph-container').innerHTML =
      `<p style="padding:24px;color:#c00">Failed to load result.json: ${err.message}</p>`;
  });

// ─── Main render ─────────────────────────────────────────────────────────────
function render(data) {
  const { layers, submodules, units } = data;

  // 1. Determine ordered list of submodules & layer bands
  const { allSubmodules, rootBands } = flattenLayers(layers);

  // 2. Compute box sizes
  const boxSizes = computeBoxSizes(allSubmodules, submodules);

  // 3. Layout: assign (x, y) to each box
  const layout = computeLayout(layers, allSubmodules, submodules, boxSizes);

  // 4. Total canvas size
  const totalW = Math.max(...Object.values(layout).map(p => p.x + boxSizes[p.submodule].w)) + PAD_X;
  const totalH = Math.max(...Object.values(layout).map(p => p.y + boxSizes[p.submodule].h)) + PAD_Y;

  const container = document.getElementById('graph-container');
  container.style.width  = totalW + 'px';
  container.style.height = totalH + 'px';

  // 5. Draw layer bands
  drawBands(container, rootBands, layout, layers, allSubmodules, boxSizes, totalW);

  // 6. Draw boxes
  const boxEls = {};
  for (const sm of allSubmodules) {
    const pos = layout[sm];
    const sz  = boxSizes[sm];
    const box = drawBox(container, sm, submodules[sm], pos, sz);
    boxEls[sm] = box;
  }

  // 7. Draw arrows
  const arrowEls = drawArrows(submodules, layout, boxSizes, totalW, totalH);

  // 8. Wire interactions
  wireInteractions(boxEls, arrowEls, submodules, units, layout, boxSizes);
}

// ─── Layer flattening ─────────────────────────────────────────────────────────
function flattenLayers(layers) {
  const allSubmodules = [];
  const rootBands = []; // {modules: string[], submodules: string[]}

  for (const rowModules of layers.root_layers) {
    const bandSubs = [];
    for (const mod of rowModules) {
      if (layers.submodule_layers && layers.submodule_layers[mod]) {
        const subRows = layers.submodule_layers[mod];
        for (const subRow of subRows)
          for (const sm of subRow) { allSubmodules.push(sm); bandSubs.push(sm); }
      } else {
        allSubmodules.push(mod);
        bandSubs.push(mod);
      }
    }
    rootBands.push({ modules: rowModules, submodules: bandSubs });
  }
  return { allSubmodules, rootBands };
}

// ─── Box sizing ───────────────────────────────────────────────────────────────
function computeBoxSizes(allSubmodules, submodules) {
  const CHAR_W = 7, COL_GAP = 12, SIDE_PAD = 28;
  const sizes = {};
  for (const sm of allSubmodules) {
    const data  = submodules[sm] || { units: [] };
    const units = data.units || [];
    const cols  = units.length > COLS_THRESHOLD ? 2 : 1;
    const rows  = Math.ceil(units.length / cols);
    const h = TITLE_H + BOX_PAD_Y + rows * UNIT_ROW_H;

    // Width: sum of max unit-name width per column + gaps + side padding
    const colWidths = Array.from({ length: cols }, (_, c) => {
      const colUnits = units.filter((_, i) => i % cols === c);
      return colUnits.length ? Math.max(...colUnits.map(u => u.length * CHAR_W)) : 0;
    });
    const titleW = sm.length * CHAR_W + SIDE_PAD;
    const colsW  = colWidths.reduce((s, w) => s + w, 0) + (cols - 1) * COL_GAP + SIDE_PAD;
    const w = Math.max(BOX_MIN_W, titleW, colsW);
    sizes[sm] = { w, h };
  }
  return sizes;
}

// ─── Layout ───────────────────────────────────────────────────────────────────
// Returns layout: { [sm]: { x, y, submodule, rowIdx } }
// rowIdx is a global vertical-row index used to detect same-row pairs for arrows.
function computeLayout(layers, allSubmodules, submodules, boxSizes) {
  const layout = {};
  let bandY = PAD_Y;
  let globalRowIdx = 0;

  for (const rootRow of layers.root_layers) {
    const moduleCols = rootRow.map(mod =>
      (layers.submodule_layers && layers.submodule_layers[mod])
        ? layers.submodule_layers[mod]
        : [[mod]]
    );

    const maxSubRows = Math.max(...moduleCols.map(c => c.length));

    const rowHeights = [];
    for (let r = 0; r < maxSubRows; r++) {
      let maxH = 0;
      for (const col of moduleCols) {
        const subRow = col[r] || [];
        for (const sm of subRow) maxH = Math.max(maxH, (boxSizes[sm] || {}).h || 0);
      }
      rowHeights.push(maxH);
    }

    let colX = PAD_X;
    for (const col of moduleCols) {
      let colW = 0;
      for (const subRow of col) {
        let rowW = subRow.reduce((s, sm) => s + ((boxSizes[sm] || {}).w || 0), 0)
                 + (subRow.length - 1) * BOX_GAP_X;
        colW = Math.max(colW, rowW);
      }

      let subRowY = bandY;
      for (let r = 0; r < col.length; r++) {
        const subRow = col[r];
        const rowW = subRow.reduce((s, sm) => s + ((boxSizes[sm] || {}).w || 0), 0)
                   + (subRow.length - 1) * BOX_GAP_X;
        let smX = colX + Math.round((colW - rowW) / 2);
        for (const sm of subRow) {
          layout[sm] = { x: smX, y: subRowY, submodule: sm, rowIdx: globalRowIdx + r };
          smX += (boxSizes[sm] || {}).w + BOX_GAP_X;
        }
        subRowY += rowHeights[r] + BOX_GAP_Y;
      }
      colX += colW + BOX_GAP_X * 2;
    }

    globalRowIdx += maxSubRows;
    const bandH = rowHeights.reduce((s, h) => s + h, 0)
                + (maxSubRows - 1) * BOX_GAP_Y
                + BOX_PAD_Y * 2;
    bandY += bandH + BOX_GAP_Y;
  }

  return layout;
}

// ─── Draw layer bands ─────────────────────────────────────────────────────────
function drawBands(container, rootBands, layout, layers, allSubmodules, boxSizes, totalW) {
  // Compute vertical extents for each band from actual box positions
  let bandIdx = 0;
  let smIdx = 0;
  const rootLayerRows = layers.root_layers;

  // Collect ordered submodules per root row
  for (let ri = 0; ri < rootLayerRows.length; ri++) {
    const rowModules = rootLayerRows[ri];
    const bandSubs = [];
    for (const mod of rowModules) {
      if (layers.submodule_layers && layers.submodule_layers[mod]) {
        for (const subRow of layers.submodule_layers[mod])
          for (const sm of subRow) bandSubs.push(sm);
      } else {
        bandSubs.push(mod);
      }
    }
    if (!bandSubs.length) continue;

    const ys = bandSubs.map(sm => layout[sm] ? layout[sm].y : 0);
    const yBots = bandSubs.map(sm => layout[sm] ? layout[sm].y + (boxSizes[sm] || {h:0}).h : 0);
    const top    = Math.min(...ys) - BOX_PAD_Y;
    const bottom = Math.max(...yBots) + BOX_PAD_Y;

    const band = document.createElement('div');
    band.className = 'layer-band';
    band.style.top    = top + 'px';
    band.style.height = (bottom - top) + 'px';
    band.style.width  = totalW + 'px';

    const label = document.createElement('div');
    label.className = 'layer-label';
    label.textContent = rowModules.join(', ');
    band.appendChild(label);

    container.appendChild(band);
  }
}

// ─── Draw a submodule box ─────────────────────────────────────────────────────
function drawBox(container, sm, data, pos, sz) {
  const box = document.createElement('div');
  box.className = 'submodule-box';
  box.dataset.sm = sm;
  box.style.left   = pos.x + 'px';
  box.style.top    = pos.y + 'px';
  box.style.width  = sz.w + 'px';
  box.style.height = sz.h + 'px';
  box.style.backgroundColor = data.color || '#ddd';

  const title = document.createElement('div');
  title.className = 'box-title';
  title.textContent = sm;
  box.appendChild(title);

  const unitsDiv = document.createElement('div');
  unitsDiv.className = 'box-units';
  const units = data.units || [];
  const cols  = units.length > COLS_THRESHOLD ? 2 : 1;
  unitsDiv.style.gridTemplateColumns = cols === 2 ? '1fr 1fr' : '1fr';

  for (const u of units) {
    const span = document.createElement('span');
    span.className = 'unit-name';
    span.textContent = u;
    span.dataset.unit = sm + '.' + u;
    span.dataset.sm   = sm;
    unitsDiv.appendChild(span);
  }

  box.appendChild(unitsDiv);
  container.appendChild(box);
  return box;
}

// ─── Arrow drawing ────────────────────────────────────────────────────────────
function drawArrows(submodules, layout, boxSizes, totalW, totalH) {
  const svg = document.getElementById('arrow-svg');
  svg.setAttribute('width',  totalW);
  svg.setAttribute('height', totalH);

  const defs = svgEl('defs');
  for (const [id, color] of [['arr-black','#333'], ['arr-red','#c00']]) {
    const marker = svgEl('marker');
    marker.setAttribute('id', id);
    marker.setAttribute('markerWidth', '8');
    marker.setAttribute('markerHeight', '8');
    marker.setAttribute('refX', '6');
    marker.setAttribute('refY', '3');
    marker.setAttribute('orient', 'auto');
    const poly = svgEl('path');
    poly.setAttribute('d', 'M0,0 L0,6 L8,3 z');
    poly.setAttribute('fill', color);
    marker.appendChild(poly);
    defs.appendChild(marker);
  }
  svg.appendChild(defs);

  // Build edge list (only cross-submodule)
  const edges = []; // { from, to, valid }
  for (const [from, smData] of Object.entries(submodules)) {
    for (const [to, valid] of Object.entries(smData.dependencies || {})) {
      if (from !== to && layout[from] && layout[to])
        edges.push({ from, to, valid });
    }
  }

  // Assign ports ─────────────────────────────────────────────────────────────
  // For each box and each of its four edges (top/bottom/left/right), collect
  // the partner boxes using that edge, then sort them by partner center-x
  // (for top/bottom) or center-y (for left/right) to minimise crossings, and
  // space the port positions evenly across the edge.

  // port maps: portOut[from][to] = {x,y}, portIn[from][to] = {x,y}
  const portOut = {}, portIn = {};
  for (const sm of Object.keys(layout)) { portOut[sm] = {}; portIn[sm] = {}; }

  // Group edges by (box, edge-side)
  // edge-side: for each directed edge, determine which side of "from" exits and
  // which side of "to" enters.
  //   - If rowIdx(from) < rowIdx(to)  → from exits bottom, to enters top
  //   - If rowIdx(from) > rowIdx(to)  → from exits top,    to enters bottom
  //   - If same rowIdx               → from exits right/left, to enters left/right

  // outgoing[sm][side] = list of partner sm, sorted by partner cx
  const outgoing = {}, incoming = {};
  for (const sm of Object.keys(layout)) {
    outgoing[sm] = { top: [], bottom: [], left: [], right: [] };
    incoming[sm] = { top: [], bottom: [], left: [], right: [] };
  }

  for (const { from, to } of edges) {
    const rf = layout[from].rowIdx, rt = layout[to].rowIdx;
    let fromSide, toSide;
    if (rf < rt)       { fromSide = 'bottom'; toSide = 'top'; }
    else if (rf > rt)  { fromSide = 'top';    toSide = 'bottom'; }
    else {
      const cf = layout[from].x + boxSizes[from].w / 2;
      const ct = layout[to].x   + boxSizes[to].w   / 2;
      fromSide = cf <= ct ? 'right' : 'left';
      toSide   = cf <= ct ? 'left'  : 'right';
    }
    outgoing[from][fromSide].push(to);
    incoming[to][toSide].push(from);
  }

  // Port assignment: place each port as close as possible to its partner port,
  // making arrows as straight as possible. Outgoing and incoming ports on the
  // same edge are assigned jointly so they never overlap.

  const MIN_PORT_GAP = 10; // minimum pixels between adjacent ports on same edge

  // Assign ports jointly per (box, side) so outgoing and incoming never overlap.
  // Tagged entries: { p, isOut, ideal }. Sort by ideal, push apart, write to maps.
  function assignJointPorts(sm, side, entries) {
    if (!entries.length) return;
    const pos = layout[sm], sz = boxSizes[sm];
    const isHoriz = side === 'top' || side === 'bottom';
    const edgeStart = isHoriz ? pos.x + MIN_PORT_GAP        : pos.y + MIN_PORT_GAP;
    const edgeEnd   = isHoriz ? pos.x + sz.w - MIN_PORT_GAP : pos.y + sz.h - MIN_PORT_GAP;

    const sorted = [...entries].sort((a, b) => a.ideal - b.ideal);
    const vals = sorted.map(e => Math.max(edgeStart, Math.min(edgeEnd, e.ideal)));
    for (let i = 1; i < vals.length; i++)
      vals[i] = Math.max(vals[i], vals[i - 1] + MIN_PORT_GAP);
    for (let i = vals.length - 2; i >= 0; i--)
      vals[i] = Math.min(vals[i], vals[i + 1] - MIN_PORT_GAP);

    sorted.forEach(({ p, isOut }, i) => {
      const v = vals[i];
      let px, py;
      if      (side === 'top')    { px = v;            py = pos.y; }
      else if (side === 'bottom') { px = v;            py = pos.y + sz.h; }
      else if (side === 'left')   { px = pos.x;        py = v; }
      else                        { px = pos.x + sz.w; py = v; }
      if (isOut) portOut[sm][p] = { x: px, y: py, side };
      else       portIn[sm][p]  = { x: px, y: py, side };
    });
  }

  // Pass 1: ideal = partner box center. Assigns outgoing; incoming get center too
  // (will be refined in pass 2 once outgoing ports are known).
  for (const sm of Object.keys(layout)) {
    for (const side of ['top', 'bottom', 'left', 'right']) {
      const out = outgoing[sm][side], inc = incoming[sm][side];
      if (!out.length && !inc.length) continue;
      const isHoriz = side === 'top' || side === 'bottom';
      const centerOf = p => isHoriz
        ? layout[p].x + boxSizes[p].w / 2
        : layout[p].y + boxSizes[p].h / 2;
      const entries = [
        ...out.map(p => ({ p, isOut: true,  ideal: centerOf(p) })),
        ...inc.map(p => ({ p, isOut: false, ideal: centerOf(p) })),
      ];
      assignJointPorts(sm, side, entries);
    }
  }

  // Pass 2: re-assign using source's now-known outgoing port as ideal for incoming.
  // Outgoing ports keep their pass-1 positions as ideals (already optimal).
  for (const sm of Object.keys(layout)) {
    for (const side of ['top', 'bottom', 'left', 'right']) {
      const out = outgoing[sm][side], inc = incoming[sm][side];
      if (!out.length && !inc.length) continue;
      const isHoriz = side === 'top' || side === 'bottom';
      const entries = [
        ...out.map(p => { const port = portOut[sm][p]; return { p, isOut: true,  ideal: isHoriz ? port.x : port.y }; }),
        ...inc.map(p => { const port = portOut[p]?.[sm]; return { p, isOut: false, ideal: port ? (isHoriz ? port.x : port.y) : (isHoriz ? layout[p].x + boxSizes[p].w / 2 : layout[p].y + boxSizes[p].h / 2) }; }),
      ];
      assignJointPorts(sm, side, entries);
    }
  }

  // Draw edges ───────────────────────────────────────────────────────────────
  const arrowEls = {};
  for (const { from, to, valid } of edges) {
    const p1 = portOut[from][to];
    const p2 = portIn[to][from];
    if (!p1 || !p2) continue;

    const color    = valid ? '#333' : '#c00';
    const markerId = valid ? 'arr-black' : 'arr-red';
    const d = bezierPath(p1, p2);

    const path = svgEl('path');
    path.setAttribute('d', d);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('marker-end', `url(#${markerId})`);
    path.setAttribute('opacity', '0.7');
    path.classList.add('arrow');
    path.dataset.from = from;
    path.dataset.to   = to;
    svg.appendChild(path);
    arrowEls[`${from}->${to}`] = path;
  }

  return arrowEls;
}

function svgEl(tag) {
  return document.createElementNS('http://www.w3.org/2000/svg', tag);
}

// Cubic bezier between two ports; control-point direction follows the port's side.
// Both outgoing (p1) and incoming (p2) control points extend outward from the box face.
function bezierPath(p1, p2) {
  const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
  const cp   = Math.max(40, dist * 0.45);

  // Outward tangent vector for a given side
  const tangent = side => {
    if (side === 'bottom') return [0,  cp];
    if (side === 'top')    return [0, -cp];
    if (side === 'right')  return [ cp, 0];
    /* left */             return [-cp, 0];
  };

  const [dx1, dy1] = tangent(p1.side);
  const [dx2, dy2] = tangent(p2.side); // also outward: cp2 sits outside p2's face

  return `M${p1.x},${p1.y} C${p1.x+dx1},${p1.y+dy1} ${p2.x+dx2},${p2.y+dy2} ${p2.x},${p2.y}`;
}

// ─── Interactions ─────────────────────────────────────────────────────────────
function wireInteractions(boxEls, arrowEls, submodules, units, layout, boxSizes) {
  const graphPane = document.getElementById('graph-pane');
  let selection = null; // { type: 'submodule'|'unit', id }

  const UNIT_CLASSES = ['dimmed', 'is-selected', 'is-callee', 'is-caller'];

  function clearSelection() {
    selection = null;
    for (const el of Object.values(boxEls)) {
      el.classList.remove('dimmed', 'focused');
      for (const u of el.querySelectorAll('.unit-name'))
        u.classList.remove(...UNIT_CLASSES);
    }
    for (const el of Object.values(arrowEls))
      el.classList.remove('dimmed');
    document.getElementById('detail-placeholder').style.display = '';
    document.getElementById('detail-content').style.display = 'none';
  }

  function applyUnitClass(el, cls) {
    // Priority: is-selected > is-callee > is-caller > dimmed
    // Once a higher-priority class is set, don't downgrade it.
    const priority = { 'is-selected': 3, 'is-callee': 2, 'is-caller': 1, 'dimmed': 0 };
    const current = UNIT_CLASSES.find(c => el.classList.contains(c));
    if (!current || priority[cls] > priority[current]) {
      el.classList.remove(...UNIT_CLASSES);
      el.classList.add(cls);
    }
  }

  function selectSubmodule(sm) {
    selection = { type: 'submodule', id: sm };

    // Outgoing: submodules this sm depends on, and the exact units referenced
    const outDeps = Object.keys(submodules[sm]?.dependencies || {});
    const referencedUnits = new Set(
      (submodules[sm]?.units || []).flatMap(name =>
        Object.keys(units[`${sm}.${name}`]?.dependencies || {})
      )
    );

    // Incoming: submodules that depend on this sm, and the exact units that reference sm's units
    const inDeps = Object.keys(submodules).filter(s =>
      s !== sm && submodules[s].dependencies?.[sm] !== undefined
    );
    const referencingUnits = new Set(
      Object.values(units)
        .filter(u => u.submodule !== sm && Object.keys(u.dependencies || {}).some(d => units[d]?.submodule === sm))
        .map(u => `${u.submodule}.${u.name}`)
    );

    const relevant = new Set([sm, ...outDeps, ...inDeps]);
    const relevantArrows = new Set([
      ...outDeps.map(d => `${sm}->${d}`),
      ...inDeps.map(s => `${s}->${sm}`),
    ]);

    for (const [s, el] of Object.entries(boxEls)) {
      if (relevant.has(s)) {
        el.classList.remove('dimmed');
        el.classList.add('focused');
        // Start all units in focused boxes as dimmed, then upgrade
        for (const u of el.querySelectorAll('.unit-name'))
          u.classList.remove(...UNIT_CLASSES);
        for (const u of el.querySelectorAll('.unit-name')) {
          const uPath = u.dataset.unit;
          if (s === sm)                       applyUnitClass(u, 'is-selected');
          else if (referencedUnits.has(uPath)) applyUnitClass(u, 'is-callee');
          else if (referencingUnits.has(uPath)) applyUnitClass(u, 'is-caller');
          else                                  applyUnitClass(u, 'dimmed');
        }
      } else {
        el.classList.add('dimmed');
        el.classList.remove('focused');
        for (const u of el.querySelectorAll('.unit-name')) {
          u.classList.remove(...UNIT_CLASSES);
          u.classList.add('dimmed');
        }
      }
    }

    for (const [key, el] of Object.entries(arrowEls)) {
      if (relevantArrows.has(key)) el.classList.remove('dimmed');
      else el.classList.add('dimmed');
    }

    showSubmoduleDetail(sm, submodules[sm], units);
  }

  function selectUnit(unitPath) {
    selection = { type: 'unit', id: unitPath };
    const unitData = units[unitPath];
    if (!unitData) return;
    const sm = unitData.submodule;

    // Outgoing: units this unit depends on (may be in same or other submodules)
    const calleeUnits = new Set(Object.keys(unitData.dependencies || {}));
    const calleeSubs  = new Set([...calleeUnits].map(u => units[u]?.submodule).filter(s => s && s !== sm));

    // Incoming: units that depend on this unit
    const callerUnits = new Set(
      Object.entries(units)
        .filter(([p, u]) => p !== unitPath && u.dependencies?.[unitPath] !== undefined)
        .map(([p]) => p)
    );
    const callerSubs = new Set([...callerUnits].map(u => units[u]?.submodule).filter(s => s && s !== sm));

    const relevant = new Set([sm, ...calleeSubs, ...callerSubs]);
    const relevantArrows = new Set([
      ...[...calleeSubs].map(s => `${sm}->${s}`),
      ...[...callerSubs].map(s => `${s}->${sm}`),
    ]);

    for (const [s, el] of Object.entries(boxEls)) {
      if (relevant.has(s)) {
        el.classList.remove('dimmed');
        el.classList.add('focused');
        for (const u of el.querySelectorAll('.unit-name'))
          u.classList.remove(...UNIT_CLASSES);
        for (const u of el.querySelectorAll('.unit-name')) {
          const uPath = u.dataset.unit;
          if (uPath === unitPath)            applyUnitClass(u, 'is-selected');
          else if (calleeUnits.has(uPath))   applyUnitClass(u, 'is-callee');
          else if (callerUnits.has(uPath))   applyUnitClass(u, 'is-caller');
          else                               applyUnitClass(u, 'dimmed');
        }
      } else {
        el.classList.add('dimmed');
        el.classList.remove('focused');
        for (const u of el.querySelectorAll('.unit-name')) {
          u.classList.remove(...UNIT_CLASSES);
          u.classList.add('dimmed');
        }
      }
    }

    for (const [key, el] of Object.entries(arrowEls)) {
      if (relevantArrows.has(key)) el.classList.remove('dimmed');
      else el.classList.add('dimmed');
    }

    showUnitDetail(unitPath, unitData);
  }

  // Click on submodule box (not on a unit name)
  for (const [sm, el] of Object.entries(boxEls)) {
    el.addEventListener('click', e => {
      e.stopPropagation();
      // If click was on a unit name, handle separately
      const unitEl = e.target.closest('.unit-name');
      if (unitEl) {
        selectUnit(unitEl.dataset.unit);
      } else {
        if (selection?.type === 'submodule' && selection.id === sm) {
          clearSelection();
        } else {
          selectSubmodule(sm);
        }
      }
    });
  }

  // Click background to clear
  graphPane.addEventListener('click', e => {
    if (e.target === graphPane || e.target === document.getElementById('graph-container')
        || e.target.classList.contains('layer-band')
        || e.target.classList.contains('layer-label')) {
      clearSelection();
    }
  });
}

// ─── Detail panel rendering ───────────────────────────────────────────────────
function showSubmoduleDetail(sm, smData, units) {
  const unitNames = smData?.units || [];
  const parts = [];
  for (const name of unitNames) {
    const path = `${sm}.${name}`;
    const u = units[path];
    if (u) {
      parts.push(`<h3>${name}</h3>` + renderMarkdown(u.description || ''));
    }
  }
  setDetail(parts.join(''));
}

function showUnitDetail(unitPath, unitData) {
  const name = unitData.name || unitPath.split('.').pop();
  setDetail(`<h3>${name}</h3>` + renderMarkdown(unitData.description || ''));
}

function setDetail(html) {
  const placeholder = document.getElementById('detail-placeholder');
  const content     = document.getElementById('detail-content');
  placeholder.style.display = 'none';
  content.style.display = '';
  content.innerHTML = html;
}

// Very simple inline markdown: handles `code`, **bold**, paragraph breaks
function renderMarkdown(text) {
  // Escape HTML
  let s = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // `code`
  s = s.replace(/`([^`]+)`/g, '<code>$1</code>');

  // **bold**
  s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

  // Split into paragraphs on blank lines
  const paras = s.split(/\n\n+/).map(p => p.trim()).filter(Boolean);
  return paras.map(p => `<p>${p.replace(/\n/g, ' ')}</p>`).join('');
}

// ─── Resizer drag ─────────────────────────────────────────────────────────────
(function() {
  const resizer = document.getElementById('resizer');
  const detail  = document.getElementById('detail-pane');
  const app     = document.getElementById('app');
  let dragging  = false, startX = 0, startW = 0;

  resizer.addEventListener('mousedown', e => {
    dragging = true;
    startX = e.clientX;
    startW = detail.offsetWidth;
    resizer.classList.add('dragging');
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });

  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const appW   = app.offsetWidth;
    const delta  = startX - e.clientX; // moving left = wider detail
    const newW   = Math.min(appW * 0.4, Math.max(appW * 0.1, startW + delta));
    detail.style.width = newW + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = false;
    resizer.classList.remove('dragging');
    document.body.style.userSelect = '';
  });
})();
</script>
</body>
</html>
